#!/usr/bin/env python

import socket, os, sys
import argparse
import json

'''
Below is command type
'''
SEND_PERF_DATA = 1

def send_perf_result(sock, profile):
    f = open('profiling-result.log', 'r')
    while True:
        str = f.readline()
        if not str:
            break
        
        msg = dict()
        msg['command'] = SEND_PERF_DATA
        msg['message'] = str
        msg['port'] = profile['port']
         
        jsonstr = json.dumps(msg)
        sock.send(jsonstr)
        feedback = sock.recv(1024) 
    f.close()
    print("End of file ...")

def run_on_slave(sock):
    '''
    TODO:
    Below profile data will be dispatched by server...
    Currently just let profile dictionay be static...
    '''
    profile = dict()
    profile['port'] = 1234 
    send_perf_result(sock, profile)

def main():
    parser = argparse.ArgumentParser(description='Profiling server')
    parser.add_argument('--bind', help='Server IP address binder, default is localhost')
    parser.add_argument('--port', help='Server port number, default is 10000') 
    args = parser.parse_args()
    
    portnumber = 10000
    bindaddr = 'localhost'
    
    if args.bind is not None:
        bindaddr = args.bind

    if args.port is not None:
        portnumber = int(args.port)

    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    except socket.error, msg:
        sys.stderr.write("[ERROR] %s\n" % msg[1])
        sys.exit(1)

    try:
        sock.connect((bindaddr, portnumber))
    except socket.error, msg:
        sys.stderr.write("[ERROR] %s" % msg)
        exit(1)
    
    run_on_slave(sock)
     
    sock.close()

if __name__ == "__main__":
    main()
